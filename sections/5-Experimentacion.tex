\section{Experimentación}

En esta sección mostraremos los resultados de las pruebas con los distintos métodos de preprocesado de datos y modelos; con el objetivo de encontrar la combinación que nos dé los mejores resultados.

Antes de comentar específicamente los distintos métodos que probaremos, explicaremos la forma en la que se han realizado estas pruebas.

Como hemos comentado anteriormente, separamos los datos de entreno y prueba aplicando la opción de \textit{stratify} y con una proporción de \textit{75/25\%} respectivamente.

Una vez separados los conjuntos de datos, los tenemos que preprocesar. Para ello, hemos utilizado el objeto \textit{Pipeline} \cite{sklearnp32:online}, el cual nos permite encadenar diferentes pasos de preprocesado para entrenar diferentes modelos de forma sencilla. Por ejemplo, si queremos probar diferentes modelos, podemos hacerlo de la siguiente forma: 

\begin{enumerate}
    \item Instanciamos los objetos de las diferentes clases de preprocesado que queramos probar con sus respectivos valores. En el caso excepcional de la \textit{primera derivada}, hemos creado nuestro propio \textit{Transformer} (objeto de ``preprocesado'') que aplica la derivada a los datos.
    \item Los agregamos a la \textit{Pipeline} en orden.
    \item Ajustamos la \textit{Pipeline} sobre el conjunto de datos de entreno.
    \item Aplicamos la \textit{Pipeline} ya configurada sobre los datos de entreno y prueba. 
\end{enumerate}


El \textit{Pipeline} nos ofrece la ventaja de poder guardar y cargar tanto el orden del procedimiento, como la configuración de los pasos intermedios para aplicarlos más adelante de forma sencilla. Por ejemplo el \textit{StandardScaler}, para modificar los datos de forma que tengan media 0 y varianza 1, guarda la media y la varianza de cada columna para poder aplicarla más adelante.

Vale la pena comentar también que este objeto de \textit{Pipeline} nos ayuda a compartir la configuración del preprocesado entre la aplicación de entrenamiento de modelos y la de visualización de las predicciones sobre los archivos \gls{bil}.

Una vez hemos preprocesado los datos y entrenado los modelos; para evaluarlos, hemos utilizado la métrica \textit{Balanced Accuracy}, la cual hemos comentado en la \textit{Sección\ \ref{sec:classification-metrics}}.


\subsection{Análisis del impacto de la primera derivada}

Para probar que, como hemos comentado antes, el aplicar la primera derivada sobre los datos nos puede ayudar a la hora de predecir, podemos comparar los resultados de entrenar con o sin derivar en la \textit{Tabla\ \ref{tab:nopreprocessing-derivative-results}}. En esta, podemos ver los resultados de entrenar la batería de modelos y su \textit{Balanced Accuracy} la cual ha mejorado un \textbf{2.255\%} respecto a no haber preprocesado los datos, por lo tanto, continuaremos aplicando la derivada en los siguientes pasos.

Además en la \textit{Tabla\ \ref{tab:nopreprocessing-derivative-results}} podemos ver un comportamiento que se repite, hay algunos modelos con un \textit{Balanced Accuracy} de $50$ (en nuestro caso es este valor, pues tenemos dos clases), lo cual nos indica que el modelo no ha sido capaz de predecir correctamente la clase minoritaria. Esto se debe a que los datos están desbalanceados y el modelo se aprovecha de ello, prediciendo siempre la clase mayoritaria.


\begin{table}[!ht]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        & \textit{Derivative} & \textit{No preprocessing} \\ \hline
        Model Name & Balanced accuracy & Balanced accuracy \\ \hline
        XGBoost & 50 & 50 \\ 
        Stochastic Gradient Descent & 50 & 50 \\ 
        Random Forest & 66.531 & 70.069 \\ 
        Quadratic Discriminant Analysis & 50 & 50 \\ 
        Multi-Layer Perceptron & 51.114 & 50 \\ 
        Linear Discriminant Analysis & 53.96 & 54.306 \\ 
        LightGBM & 71.846 & 62.632 \\ 
        K-Neighbors & 71.289 & 82.46 \\ 
        Hist Gradient Boosting & 68.97 & 58.988 \\ 
        Extra Trees & 78.756 & 76.438 \\ 
        Decision Tree & \textbf{67.224} & 50 \\ \hline
        \textit{Average} & \textbf{61.790} & 59.535 \\ \hline
    \end{tabular}
    \caption{Comparación de los resultados de entrenar utilizando la derivada y sin preprocesar. Fuente propia.}\ \label{tab:nopreprocessing-derivative-results}
\end{table}

\subsection{Análisis del impacto de aplicar la transformada}

Podemos ver los resultados de entrenar utilizando la transformada sobre los datos derivados en la \textit{Tabla\ \ref{tab:derivative-transformed-results}}, vemos que la métrica \textit{Balanced Accuracy} en general empeora en un \textbf{1.12\%}, así que continuaremos las pruebas sin añadir la transformada al preprocesado.

\begin{table}[!h]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
            & \textit{Transformer \& derivative} & \textit{Derivative} \\ \hline
            Model Name & Balanced accuracy & Balanced accuracy \\ \hline
            XGBoost & 50 & 50 \\ 
            Stochastic Gradient Descent & 50 & 50 \\ 
            Random Forest & 66.531 & 66.531 \\ 
            Quadratic Discriminant Analysis & \textbf{55.149} & 50 \\ 
            Multi-Layer Perceptron & 50 & 51.114 \\ 
            Linear Discriminant Analysis & 52.529 & 53.96 \\ 
            LightGBM & 71.846 & 71.846 \\ 
            K-Neighbors & \textbf{56.143} & 71.289 \\ 
            Hist Gradient Boosting & 68.97 & 68.97 \\ 
            Extra Trees & 78.967 & 78.756 \\ 
            Decision Tree & 67.224 & 67.224 \\ \hline
            \textit{Average} & 60.669 & \textbf{61.790} \\ \hline
    \end{tabular}
    \caption{Comparación de los resultados de entrenar transformando y derivando los datos; frente a solo derivando. Fuente propia.}\ \label{tab:derivative-transformed-results}
\end{table}

\subsection{Análisis del impacto de la estandarización de los datos}

Al aplicar la estandarización de los datos después de derivarlos obtenemos los resultados de la \textit{Tabla\ \ref{tab:derivative-standarization-results}}, los cuales en general son notablementes mejores que los anteriores, viendo una mejora del \textbf{2.74\%} en la \textit{Balanced Accuracy}. Estas mejoras ocurren en los modelos marcados en la tabla, \textit{QDA} y \textit{MLP}.


\begin{table}[!h]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        & \textit{Derivative \& Scaler} & \textit{Derivative} \\ \hline
        Model Name & Balanced accuracy & Balanced accuracy \\ \hline
        XGBoost & 50 & 50 \\
        Stochastic Gradient Descent & 49.834 & 50 \\ 
        Random Forest & 66.531 & 66.531 \\ 
        Quadratic Discriminant Analysis & \textbf{72.358} & 50 \\ 
        Multi-Layer Perceptron & \textbf{59.41} & 51.114 \\ 
        Linear Discriminant Analysis & 53.96 & 53.96 \\ 
        LightGBM & 71.981 & 71.846 \\ 
        K-Neighbors & 70.807 & 71.289 \\ 
        Hist Gradient Boosting & 68.97 & 68.97 \\ 
        Extra Trees & 78.756 & 78.756 \\ 
        Decision Tree & 67.224 & 67.224 \\ \hline
        \textit{Average} & \textbf{64.530} & 61.790 \\ \hline
    \end{tabular}
    \caption{Comparación de los resultados de entrenar derivando y estandarizando los datos; frente a solo derivando. Fuente propia.}\ \label{tab:derivative-standarization-results}
\end{table}


\subsection{Impacto del aumento y disminución de dimensionalidad de los datos}


Por último, aun siendo un paso generalmente recomendado, el aumento y disminución de dimensionalidad nos ha dado los resultados de la \textit{Tabla\ \ref{tab:derivative-standarization-dimensionality-results}}, los cuales son significativamente peores que los anteriores empeorando la \textit{Balanced Accuracy} en un \textbf{5.66\%}. Por lo tanto, continuaremos con los datos derivados y estandarizados sin aumentar o disminuir la dimensionalidad de los datos.

\begin{table}[!h]
    \centering
    \resizebox{\textwidth}{!}{\begin{tabular}{|c|c|c|}
        \hline
        & \textit{Derivative \& Scaler \& Polynomial Features \& PCA} & \textit{Derivative \& Scaler} \\ \hline
        Model Name & Balanced accuracy & Balanced accuracy \\ \hline
        XGBoost & 50 & 50 \\ 
        Stochastic Gradient Descent & 52.439 & 49.834 \\ 
        Random Forest & 61.939 & 66.531 \\ 
        Quadratic Discriminant Analysis & {63.234} & {72.358} \\ 
        Multi-Layer Perceptron & 54.682 & 59.41 \\ 
        Linear Discriminant Analysis & 50.903 & 53.96 \\ 
        LightGBM & {62.933} & {71.981} \\ 
        K-Neighbors & {64.092} & {70.807} \\ 
        Hist Gradient Boosting & 61.924 & 68.97 \\ 
        Extra Trees & 70.37 & 78.756 \\ 
        Decision Tree & 55.014 & 67.224 \\ \hline
        \textit{Average} & \textbf{58.866} & \textbf{64.530} \\ \hline
    \end{tabular}}
    \caption{Comparación de los resultados de entrenar derivando, estandarizando y ajustando la dimensionalidad de los datos; frente a solo derivando y estandarizando. Fuente propia.}\ \label{tab:derivative-standarization-dimensionality-results}
\end{table}


\subsection{Selección de modelos y \textit{hyperparameter tuning}}\ \label{sec:entrenamiento}

Una vez encontrada una combinación de pasos de preprocesado que nos mejora los resultados, podemos pasar al siguiente paso de selección de los modelos. Habiendo entrenado ya los modelos, vemos en la \textit{Tabla\ \ref{tab:final-training-results}} que algunos hacen \textit{overfitting}. El \textit{overfitting} ocurre cuando un modelo se ajusta demasiado a los datos con los que ha entrenado y no generaliza bien, es decir que predice mejor los datos con los que ha entrenado que datos nuevos. Esto lo podemos ver en la tabla comparando los valores de las columnas \textit{Train} y \textit{Test score}.

Donde lo podemos ver más claramente es en \textit{KNeighbors}, vemos en la \textit{Figura\ \ref{fig:lc-knn}} que, para cualquier cantidad de datos con los que entrenemos el modelo, siempre predecirá bien con los que ha entrenado y no tanto con los demás. Nuestro objetivo es intentar que ambos valores no sean tan dispares y que sean lo más altos posibles, para ello aplicaremos \textit{hyperparameter tuning}.

\begin{table}[!ht]
    \centering
    \begin{tabular}{|c|ccc|}
    \hline
        Model Name & Train score & Test score & Balanced accuracy \\ \hline
        XGBoost & 82 & 82 & 50 \\ 
        Stochastic Gradient Descent & 64.815 & 56.444 & 49.834 \\ 
        Random Forest & \textbf{99.926} & \textbf{87.778} & 66.531 \\ 
        Quadratic Discriminant Analysis & \textbf{96.148} & \textbf{83.111} & 72.358 \\ 
        Multi-Layer Perceptron & 90.815 & 84 & 59.41 \\ 
        Linear Discriminant Analysis & \textbf{85.333} & \textbf{78.222} & 53.96 \\ 
        LightGBM & 82.222 & 72.222 & 71.981 \\ 
        K-Neighbors & \textbf{100} & \textbf{86.889} & 70.807 \\ 
        Hist Gradient Boosting & \textbf{78.444} & \textbf{70.444} & 68.97 \\ 
        Extra Trees & \textbf{99.63} & \textbf{90.444} & 78.756 \\ 
        Decision Tree & 56.963 & 58.889 & 67.224 \\
    \hline
    \end{tabular}
    \caption{Tabla ampliada de los resultados de entrenar los modelos utilizando la derivada y \textit{StandardScaler}. Fuente propia.}\ \label{tab:final-training-results}
\end{table}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.7\linewidth]{media/images/learing-curves-knn.png}
    \caption{Gráfico de la curva de aprendizaje del modelo \textit{K-Neighbors} entrenándolo y probándolo sobre los datos de entreno únicamente. Fuente propia}\ \label{fig:lc-knn}
\end{figure}

El \textit{hyperparameter tuning} tiene como objetivo encontrar un conjunto de parámetros que maximice el rendimiento del modelo sobre los datos de prueba. En nuestro caso, como los datos están desbalanceados, podemos utilizar como función a optimizar el \textit{Balanced Accuracy}. Como cada modelo es distinto, debemos encontrar los parámetros adecuados para cada uno. 

Como no todos los modelos nos han dado buenos resultados y el \textit{hyperparameter tuning} es un proceso costoso, para ahorrarnos tiempo podemos utilizar solamente los mejores, como hemos visto en la \textit{Tabla\ \ref{tab:final-training-results}} hay modelos que tienen mejores resultados que otros. Así que escogeremos los cuatro con mejor \textit{balanced accuracy}, es decir: \textit{Extra Trees, Quadratic Discriminant Analysis, LightGBM y K-Neighbors}.

Realizaremos el \textit{hyperparameter tuning} en dos pasos, primeramente utilizaremos \textit{Random Search} y después \textit{Grid Search}, ya implementados en \textit{sklearn}.
Ambos métodos utilizan \textit{cross-validation}, una técnica para evitar el \textit{overfitting} (y el \textit{underfitting}) que consiste en la división de los datos de entreno en partes iguales.

Una vez divididos los datos de entreno en \textit{N} partes, se itera sobre cada una de ellas, utilizando \textit{N-1} partes para entrenar el modelo y la restante para evaluarlo. Una vez obtenemos los modelos entrenados sobre las diferentes partes, los comparamos con la función de rendimiento que queramos optimizar y seleccionamos el mejor. Una vez seleccionado el mejor modelo, lo probamos sobre los datos de prueba y obtenemos los resultados finales. Podemos ver este proceso gráficamente en la \textit{Figura\ \ref{fig:cross-validation}}.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.7\linewidth]{media/images/cross-validation.png}
    \caption{\textit{Cross-validation} explicado gráficamente. Fuente:\ \cite{31Crossv20:online}}\ \label{fig:cross-validation}
\end{figure}


El \textit{random search} consiste en la búsqueda de estos parámetros habiendo definido un rango de posibilidades. Es decir, para cada parámetro que le queramos pasar al modelo definiremos un rango de valores que puede tener, entonces el \textit{random search} entrena el modelo repetidas veces con una permutación aleatoria de sus parámetros y se guarda los resultados. Podemos ver un ejemplo en el \textit{Código\ \ref{code:random-search-example}}.
Podemos ir probando diferentes parámetros y rangos hasta que estemos satisfechos con el resultado.


Una vez estemos contentos con los resultados, los refinaremos utilizando \textit{grid search}. A diferencia del \textit{random search}, el \textit{grid search} prueba todas las posibles combinaciones que le pasemos como parámetro y, consecuentemente, es mucho más lento. Por ello, utilizaremos el \textit{grid search} con los valores de los parámetros que dan los cinco mejores resultados del paso anterior, los cuales son potencialmente los mejores. Una vez definido un rango de parámetros para cada modelo seleccionado, obtenemos los resultados de la \textit{Tabla\ \ref{tab:hyperparameter-tuning-results}} donde vemos que los resultados del \textit{Random Search} y los de \textit{Grid Search} son iguales, salvo por \textit{Extra Trees}, en el cual el hacer \textit{Grid Search} sí que nos aporta mejores resultados. En general, vemos que hemos obtenido resultados parecidos a los de los modelos sin refinar, salvo por \textit{K-Neighbors}, que ha mejorado en un \textbf{19.467\%}, y \textit{Extra Trees}, que ha empeorado en un \textbf{12.586\%}.
Por lo tanto, deberíamos ajustar el rango de los parámetros que les pasamos a los modelos que no han dado buenos resultados y volver a entrenarlos hasta que estemos satisfechos. En nuestro caso no lo haremos, sino que retrocederemos unos pasos y probaremos otras técnicas.

\begin{table}[!h]
    \centering
    \resizebox{\textwidth}{!}{\begin{tabular}{|c|ccc|}
        \hline
        Model name & Train score & Test score & Balanced accuracy \\ \hline
        RS K-Neighbors & 100 & 90.274 & 90.274 \\ 
        GS K-Neighbors & 100 & 90.274 & 90.274 \\ 
        RS Quadratic Discriminant Analysis & 97.491 & 72.358 & 72.358 \\ 
        GS Quadratic Discriminant Analysis & 97.491 & 72.358 & 72.358 \\ 
        RS LightGBM & 86.013 & 71.018 & 71.018 \\ 
        GS LightGBM & 86.013 & 71.018 & 71.018 \\ 
        GS Extra Trees & 82.957 & 66.17 & 66.17 \\ 
        RS Extra Trees & 69.492 & 65.854 & 65.854 \\ \hline
        \end{tabular}}
    \caption{Resultados del primer entrenamiento con hyperparameter tuning. Fuente propia.}\ \label{tab:hyperparameter-tuning-results}
\end{table}
\clearpage

\subsection{Balanceo de datos}\ \label{sec:i2-balance}

\subsubsection{\textit{Undersampling}}

Al probar los algoritmos mencionados anteriormente, obtenemos los resultados de la \textit{Tabla\ \ref{tab:undersampling-methods}}. 
Hemos agregado una columna más, \textit{Avg. score diff}, que nos indica la diferencia entre el \textit{Train} y \textit{Test score} para decidir mejor, pues las \textit{Balanced Accuracy} nos daba resultados bastante parecidos. Esta ``nueva'' métrica no indica cuánto \textit{overfitting} hacen los modelos que se entrenan sobre el dataset generado, por lo tanto, cuanto más cercana a \textit{0} sea, mejor. Podemos ver que, en general, los diferentes \textit{Near Miss}, obtienen resultados bastante peores que los otros métodos. En cuanto a los otros tres algoritmos restantes, podemos ver que el \textit{Tomek Links} es el único que tiene mejores resultados que el \textit{dataset} sin hacer \textit{undersampling}, por lo tanto, continuaremos con este método.

\begin{table}[!ht]
    \centering
    \begin{tabular}{|c|cc|} \hline
        & Avg. score diff & Avg. Balanced Accuracy \\ \hline
        \textit{\textbf{No undersampling}} & 7.805 & 64.53 \\ 
        \textit{\textbf{TL}} & 7.950 & 65.236 \\ 
        \textit{ENN (MODE)} & 8.953 & 64.575 \\ 
        \textit{RUS} & 9.176 & 63.656 \\ 
        \textit{NM v3} & 9.883 & 61.999 \\ 
        \textit{ENN (ALL)} & 10.410 & 66.523 \\ 
        \textit{NM v1} & 35.263 & 62.754 \\ 
        \textit{NM v2} & 41.914 & 61.315 \\ \hline
    \end{tabular}
    \caption{Resultado de entrenar los modelos básicos sobre el \textit{dataset} reducido con los diferentes métodos. Fuente: propia.}\ \label{tab:undersampling-methods}
\end{table}

Una vez hemos aplicado \textit{Tomek Links} sobre el \textit{dataset}, nos quedamos con el número de muestras de la \textit{Figura\ \ref{fig:balance-tl}} y la \textit{Tabla\ \ref{tab:balance-tl-comparison}}; en las cuales podemos ver que tan solo se han eliminado $12$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.8\linewidth]{media/images/balance.png}
    \caption{Comparación del balance de la clase objetivo antes y después de utilizar el método de \textit{undersampling ENN (ALL)}. Fuente propia.}\ \label{fig:balance-tl}
\end{figure}

\begin{table}
    \centering
    \begin{tabular}{|c|cc|} \hline
        & Good samples & Bad samples \\ \hline
        Before undersampling & 1107 & 243 \\
        After undersampling & 1095 & 243 \\ \hline
    \end{tabular}
    \caption{Comparación de las muestras antes y después de aplicar \textit{Tomek Links}. Fuente propia.}\ \label{tab:balance-tl-comparison}
\end{table}

\subsubsection{\textit{Oversampling}}

Para balancear el \textit{dataset}, como hemos comentado en la \textit{Sección\ \ref{sec:oversampling}}, hemos utilizado los sintetizadores de la librería \textit{sdv} para generar datos sintéticos. Además de los sintetizadores, la librería nos ofrece métodos para evaluar la calidad de los datos generados en forma de \textit{quality reports}. Estos \textit{quality reports} contienen la similitud estadística de los datos generados con los datos reales.

Una vez entrenados los sintetizadores y generados los datos, obtenemos los resultados de la \textit{Tabla\ \ref{tab:oversampling-quality-report}}, en los cuales podemos ver que la calidad de los datos generados por el sintetizador \textit{Gaussian Copula Synthesizer} son mejores.

\begin{table}[!ht]
    \centering
    \resizebox{0.8\linewidth}{!}{\begin{tabular}{|c|ccc|} \hline
        Synthesizer & Column Shapes & Column Pair Trends & Overall Quality \\ \hline
        Gaussian Copula Synthesizer & 94.75 & 99.83 & 97.29 \\
        TVAE Synthesizer & 84.37 & 74.97 & 79.64 \\ \hline
    \end{tabular}}
    \caption{Resultados del \textit{quality report} de los datos generados con los sintetizadores. Fuente propia}\ \label{tab:oversampling-quality-report}
\end{table}

Una vez tenemos los sintetizadores entrenados sobre la clase minoritaria, generamos nuevos datos y los añadimos al \textit{dataset} original, entrenamos los modelos básicos y obtenemos los resultados de la \textit{Tabla\ \ref{tab:balanced-basic-training}} donde podemos ver que, en general, los modelos resultantes son peores que los que se han entrenado con datos que no utilizan ningún sintetizador. Por lo tanto, mantendremos el \textit{undersampling}, pero no utilizaremos \textit{oversampling} en los siguientes pasos.

\begin{table}[!ht]
    \centering
    \begin{tabular}{|c|ccc|}\hline
        Model Name & Train score & Test score & Balanced accuracy \\ \hline
        XGBoost & 89.908 & 78.889 & 55.812 \\ 
        Stochastic Gradient Descent & 79.53 & 69.333 & 53.839 \\ 
        Random Forest & 97.42 & 82.444 & 66.17 \\ 
        Quadratic Discriminant Analysis & 93.005 & 82.667 & 53.779 \\ 
        Multi-Layer Perceptron & 94.209 & 80.889 & 64.74 \\ 
        Linear Discriminant Analysis & 87.041 & 76.889 & 53.628 \\ 
        LightGBM & 90.195 & 77.111 & 52.319 \\ 
        K-Neighbors & 100 & 85.778 & 76.393 \\ 
        Hist Gradient Boosting & 86.812 & 77.333 & 52.936 \\ 
        Extra Trees & 90.998 & 80 & 57.934 \\ 
        Decision Tree & 83.658 & 80.222 & 51.325 \\ \hline
        \textit{Average} & 90.252 & 79.232 & \textbf{58.079} \\ \hline
    \end{tabular}
    \caption{Resultados de entrenar los modelos básicos habiendo balanceado el \textit{dataset}. Fuente propia.}\ \label{tab:balanced-basic-training}
\end{table}

\subsection{Nuevos modelos}

Hay dos tipos de modelos más complejos que no hemos probado que pueden darnos mejores resultados, estos son \textit{Voting Classifier} y \textit{Bagging Classifier}. El primero, \textit{Voting Classifier}, entrena los modelos que lo componen sobre el \textit{dataset} y, a la hora de predecir, extrapola su predicción en base a las predicciones de estos modelos. Es decir, realiza una votación y la clase que más se vote es la que sale como predicción como podemos ver en la \textit{Figura\ \ref{fig:voting-classifiers}}. Hay dos tipos de votación, \textit{hard} y \textit{soft}, \textit{hard} utiliza la clase predicha de los modelos, mientras que \textit{soft} suma las probabilidades de las clases a predecir y suele ser más preciso \cite{Ensemble96:online}. 

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.7\linewidth]{media/images/majority_voting.png}
    \caption{Explicación gráfica del proceso de entreno y predicción de un \textit{Voting Classifier}. Fuente \cite{Ensemble96:online}.}\ \label{fig:voting-classifiers}
\end{figure}

Por otro lado el \textit{Bagging Classifier} entrena el mismo modelo sobre un subconjunto aleatorio del \textit{dataset} y luego agrega los resultados de las predicciones, ya sea haciendo la media o realizando una votación, para obtener una predicción final.\ \cite{sklearne53:online}


Antes de entrenar estos modelos, hemos de decidir qué otros modelos los compondran, por lo tanto, escogeremos los que han tenido mejores resultados al entrenarlos sobre el \textit{dataset} balanceado. Estos son los que mejores resultados tienen en la \textit{Tabla\ \ref{tab:tomeklinks-basic-training}}, es decir, \textit{K-Neighbors}, \textit{Multi-Layer Perceptron}, \textit{Random Forest} y \textit{Extra Trees}.

\begin{table}[!ht]
    \centering
    \begin{tabular}{|c|ccc|}
    \hline
        Model Name & Train score & Test score & Balanced accuracy \\ \hline
        XGBoost & 81.839 & 82 & 50 \\ 
        Stochastic Gradient Descent & 65.845 & 57.111 & 54.095 \\ 
        Random Forest & 100 & 86.444 & 63.791 \\ 
        Quadratic Discriminant Analysis & 96.487 & 83.778 & 72.282 \\ 
        Multi-Layer Perceptron & 90.284 & 82.889 & 60.659 \\ 
        Linear Discriminant Analysis & 85.202 & 77.778 & 54.17 \\ 
        LightGBM & 83.857 & 73.333 & 73.141 \\ 
        K-Neighbors & 100 & 87.111 & 71.424 \\ 
        Hist Gradient Boosting & 78.625 & 70.889 & 70.205 \\ 
        Extra Trees & 99.552 & 91.111 & 80.608 \\ 
        Decision Tree & 57.1 & 58.889 & 67.224 \\ \hline
    \end{tabular}
    \caption{Resultados de entrenar los modelos básicos habiendo balanceado el \textit{dataset} utilizando el método \textit{Tomek Links}. Fuente propia.}\ \label{tab:tomeklinks-basic-training}
\end{table}

Al entrenar los \textit{Voting} y \textit{Bagging Classifiers}, obtenemos los resultados de la \textit{Tabla\ \ref{tab:voting-bagging-results}}. En general, los \textit{Voting} han obtenido resultados algo mejores que los \textit{Bagging Classifiers}, podría ser por la cantidad de datos sobre los que ha entrenado cada submodelo. De todas formas, en general, obtenemos mejores resultados que utilizando modelos básicos.

\begin{table}[!ht]
    \centering
    \resizebox{\textwidth}{!}{\begin{tabular}{|c|cccc|cccc|}    \hline
        & \multicolumn{4}{|c|}{Balanced dataset} & \multicolumn{4}{c|}{Normal dataset} \\ \hline
        Model Name & Train score & Test score & f2score & Balanced accuracy & Train score & Test score & f2score & Balanced accuracy \\ \hline
        Voting (RF, ET, KNN) & 100 & 87.111 & 39.216 & 66.606 & 100 & 86.889 & 40.278 & 66.953 \\
        Voting (MLP, ET) & 100 & 90.444 & 60.847 & 77.311 & 100 & 89.333 & 58.047 & 75.67 \\
        Voting (KNN, ET) & 99.402 & 87.111 & 47.17 & 69.979 & 99.111 & 86.667 & 46.917 & 69.708 \\
        Voting (KNN, ET) & 100 & 87.556 & 44.077 & 68.805 & 100 & 87.333 & 42.818 & 68.187 \\
        Bagging (RF) & 87.145 & 82.667 & 6.079 & 52.334 & 86.889 & 82 & 3.049 & 50.964 \\
        Bagging (MLP) & 91.031 & 82.667 & 18.732 & 56.67 & 90.741 & 83.111 & 17.493 & 56.459 \\
        Bagging (KNN) & 83.931 & 83.333 & 11.976 & 54.667 & 83.407 & 83.111 & 9.063 & 53.568 \\
        Bagging (ET) & 93.946 & 84.222 & 16.369 & 56.655 & 93.259 & 82.889 & 10.479 & 53.914 \\ \hline
        \end{tabular}
        }
        \caption{Resultados de entrenar los diferentes \textit{Voting} y \textit{Bagging Classifiers} que hemos preparado con los resultados del \textit{hyperparameter tuning}. Fuente propia.}\ \label{tab:voting-bagging-results}
\end{table}

\subsubsection{Hyperparameter tuning}

Además de los nuevos modelos, podemos volver a probar a hacer \textit{hyperparameter tuning} sobre el dataset balanceado, obteniendo los resultados de la \textit{Tabla\ \ref{tab:hyperparameter-tuning-results-v2}} que, compárandolos con los resultados del anterior \textit{hyperparameter tuning}, vemos que han mejorado un poco en general, por lo que eligiríamos estos últimos para predecir. 

\begin{table}[!ht]
    \centering
    \begin{tabular}{|c|ccc|} \hline
        Model name & Train score & Test score & Balanced accuracy \\ \hline
        RS K-Neighbors & 100 & 91.509 & 91.509 \\ 
        GS K-Neighbors & 100 & 91.509 & 91.509 \\ 
        RS Quadratic Discriminant Analysis & 97.694 &2.282 & 72.282 \\ 
        GS Quadratic Discriminant Analysis & 97.694 & 72.282 & 72.282 \\ 
        GS LightGBM & 85.107 & 71.304 & 71.304 \\ 
        RS LightGBM & 85.748 & 69.798 & 69.798 \\ 
        RS Extra Trees & 50 & 50 & 50 \\ 
        GS Extra Trees & 50 & 50 & 50 \\ \hline
    \end{tabular}
    \caption{Resultado del \textit{hyperparameter tuning} con el \textit{dataset} balanceado. Fuente propia.}\ \label{tab:hyperparameter-tuning-results-v2}
\end{table}